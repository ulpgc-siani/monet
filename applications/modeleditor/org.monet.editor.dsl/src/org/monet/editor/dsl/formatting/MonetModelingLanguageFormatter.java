/*
 * generated by Xtext
 */
package org.monet.editor.dsl.formatting;

import org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter;
import org.eclipse.xtext.formatting.impl.FormattingConfig;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.util.Pair;
import org.monet.editor.dsl.services.MonetModelingLanguageGrammarAccess;

/**
 * This class contains custom formatting description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#formatting
 * on how and when to use it
 * 
 * Also see {@link org.eclipse.xtext.xtext.XtextFormattingTokenSerializer} as an
 * example
 */
@SuppressWarnings("restriction")
public class MonetModelingLanguageFormatter extends AbstractDeclarativeFormatter {

  @Override
  protected void configureFormatting(FormattingConfig c) {
    MonetModelingLanguageGrammarAccess grammar = (MonetModelingLanguageGrammarAccess) getGrammarAccess();

    c.setAutoLinewrap(200);
    c.setWrappedLineIndentation(2);
    
    // It's usually a good idea to activate the following three statements.
    // They will add and preserve newlines around comments
    c.setLinewrap(0, 1, 2).before(grammar.getSL_COMMENTRule());
    c.setLinewrap(0, 1, 2).before(grammar.getML_COMMENTRule());
    c.setLinewrap(0, 1, 1).after(grammar.getML_COMMENTRule());

    //find common keywords an specify formatting for them
    for (Pair<Keyword, Keyword> pair : grammar.findKeywordPairs("(", ")")) {
      c.setNoSpace().before(pair.getFirst());
      c.setNoSpace().after(pair.getFirst());
      c.setNoSpace().before(pair.getSecond());
    }
    for (Pair<Keyword, Keyword> pair : grammar.findKeywordPairs("[", "]")) {
      c.setNoSpace().after(pair.getFirst());
      c.setNoSpace().before(pair.getSecond());
    }
    for (Pair<Keyword, Keyword> pair : grammar.findKeywordPairs("<", ">")) {
      c.setNoSpace().after(pair.getFirst());
      c.setNoSpace().before(pair.getSecond());
    }
    for (Keyword comma : grammar.findKeywords(",")) {
      c.setNoSpace().before(comma);
    }
    for (Keyword keyword : grammar.findKeywords(".")) {
      c.setNoSpace().before(keyword);
      c.setNoSpace().after(keyword);
    }
    for (Keyword comma : grammar.findKeywords(";")) {
      c.setNoSpace().before(comma);
    }
    
    for (Pair<Keyword, Keyword> pair : grammar.findKeywordPairs("{", "}")) {
      c.setLinewrap(0, 1, 1).after(pair.getFirst());
      c.setIndentationIncrement().after(pair.getFirst());
      c.setLinewrap(1, 1, 1).after(pair.getSecond());
      c.setIndentationDecrement().before(pair.getSecond());
    }
    
    c.setLinewrap().after(grammar.getImportRule());
    c.setLinewrap(2).between(grammar.getImportRule(), grammar.getPackageDeclarationRule());
    c.setLinewrap(2).before(grammar.getCodeRule());
    c.setLinewrap().after(grammar.getCodeRule());
    
    c.setLinewrap(2, 2, 2).before(grammar.getDefinitionRule());
    c.setLinewrap(1, 2, 2).before(grammar.getFeatureRule());
    c.setLinewrap(1, 2, 2).before(grammar.getManifestFeatureRule());
    c.setLinewrap(1, 1, 1).before(grammar.getPropertyFeatureRule());
    c.setLinewrap(1, 1, 1).after(grammar.getDefinitionRule());
    c.setLinewrap(1, 1, 1).after(grammar.getProjectModelRule());
    c.setLinewrap(1, 1, 1).after(grammar.getDistributionModelRule());
    c.setLinewrap(1, 1, 2).after(grammar.getFeatureRule());
    c.setLinewrap(1, 1, 2).after(grammar.getManifestFeatureRule());
    c.setLinewrap(1, 1, 1).after(grammar.getPropertyFeatureRule());
    
    c.setLinewrap(1, 2, 2).before(grammar.getMethodRule());
    c.setLinewrap(1, 2, 2).before(grammar.getFunctionRule());
    
    c.setLinewrap().after(grammar.getSchemaPropertyRule());
    c.setLinewrap().after(grammar.getSchemaSectionRule());
    c.setLinewrap(2).between(grammar.getSchemaPropertyRule(), grammar.getMethodRule());
    
    c.setLinewrap().between(grammar.getXBlockExpressionAccess().getSemicolonKeyword_2_1(), grammar.getXBlockExpressionAccess().getRightCurlyBracketKeyword_3());
    c.setLinewrap().after(grammar.getXBlockExpressionAccess().getSemicolonKeyword_2_1());
  }
}
