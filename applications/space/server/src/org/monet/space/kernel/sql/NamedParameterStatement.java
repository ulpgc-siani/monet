package org.monet.space.kernel.sql;

import org.monet.space.kernel.agents.AgentLogger;
import org.monet.space.kernel.exceptions.ParameterNotFoundInQueryException;

import java.io.IOException;
import java.io.InputStream;
import java.sql.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;


/**
 * This class wraps around a {@link PreparedStatement} and allows the programmer to set parameters by name instead
 * of by index.  This eliminates any confusion as to which parameter index represents what.  This also means that
 * rearranging the SQL statement or adding a parameter doesn't involve renumbering your indices.
 * Code such as this:
 * <p/>
 * Connection con=getConnection();
 * String query="select * from my_table where name=? or address=?";
 * PreparedStatement p=con.prepareStatement(query);
 * p.setString(1, "bob");
 * p.setString(2, "123 terrace ct");
 * ResultSet rs=p.executeQuery();
 * <p/>
 * can be replaced with:
 * <p/>
 * Connection con=getConnection();
 * String query="select * from my_table where name=@name or address=@address";
 * NamedParameterStatement p=new NamedParameterStatement(con, query);
 * p.setString("name", "bob");
 * p.setString("address", "123 terrace ct");
 * ResultSet rs=p.executeQuery();
 *
 * @author adam_crume
 *         <p/>
 *         Modified by (2010/03/02)
 * @author rayco_arana
 */
public class NamedParameterStatement {
	private static final HashMap<String, Map<String, List<Integer>>> indexCache = new HashMap<String, Map<String, List<Integer>>>();
	private static final HashMap<String, String> parsedQueryCache = new HashMap<String, String>();
	private static final HashMap<String, String[]> parsedQueryArrayCache = new HashMap<String, String[]>();
	private static final HashMap<String, String> debugParams = new HashMap<String, String>();

	/**
	 * The statement this object is wrapping.
	 */
	private final PreparedStatement statement;
	private final String query;
	private final String parsedQuery;

	private static final AgentLogger agentLogger = AgentLogger.getInstance();
	private static boolean debugMode = false;
	private static int databaseQueryElapsedTimeWarning = 3000;
	private static java.util.Date startTraceDate = new java.util.Date();

	/**
	 * Maps parameter names to arrays of ints which are the parameter indices.
	 */
	private final Map<String, List<Integer>> indexMap;

	/**
	 * Creates a NamedParameterStatement.  Wraps a call to
	 * c.{@link Connection#prepareStatement(java.lang.String) prepareStatement}.
	 *
	 * @param connection the database connection
	 * @param query      the parameterized query
	 * @throws SQLException if the statement could not be created
	 */
	public NamedParameterStatement(Connection connection, String query) throws SQLException {
		this.query = query;
		if (indexCache.containsKey(query)) {
			indexMap = indexCache.get(query);
			parsedQuery = parsedQueryCache.get(query);
		} else {
			indexMap = new HashMap<String, List<Integer>>();
			parsedQuery = parse(query, indexMap);
			indexCache.put(query, indexMap);
			parsedQueryCache.put(query, parsedQuery);
		}
		statement = connection.prepareStatement(parsedQuery);
	}

	/**
	 * Creates a NamedParameterStatement.  Wraps a call to
	 * c.{@link Connection#prepareStatement(java.lang.String) prepareStatement}.
	 *
	 * @param connection        the database connection
	 * @param query             the parameterized query
	 * @param autoGeneratedKeys
	 * @throws SQLException if the statement could not be created
	 */
	public NamedParameterStatement(Connection connection, String query, int autoGeneratedKeys) throws SQLException {
		String[] queries = null;
		this.query = query.trim();
		if (indexCache.containsKey(this.query)) {
			indexMap = indexCache.get(this.query);
			queries = parsedQueryArrayCache.get(this.query);
			parsedQuery = queries[0];
		} else {
			indexMap = new HashMap<String, List<Integer>>();
			queries = this.query.split(";");
			parsedQuery = parse(queries[0], indexMap);
			queries[0] = parsedQuery;
			indexCache.put(this.query, indexMap);
			parsedQueryArrayCache.put(this.query, queries);
		}
		if (queries.length == 1)
			statement = connection.prepareStatement(parsedQuery, autoGeneratedKeys);
		else
			statement = connection.prepareStatement(parsedQuery, new String[]{queries[1]});
	}

	public static void setDebugMode(boolean value) {
		debugMode = value;
	}

	public static void setDatabaseQueryExecutionTimeWarning(int value) {
		databaseQueryElapsedTimeWarning = value;
	}

	/**
	 * Parses a query with named parameters.  The parameter-index mappings are put into the map, and the
	 * parsed query is returned.  DO NOT CALL FROM CLIENT CODE.  This method is non-private so JUnit code can
	 * test it.
	 *
	 * @param query    query to parse
	 * @param paramMap map to hold parameter-index mappings
	 * @return the parsed query
	 */
	static final String parse(String query, Map<String, List<Integer>> paramMap) {
		// I was originally using regular expressions, but they didn't work well for ignoring
		// parameter-like strings inside quotes.
		int length = query.length();
		StringBuffer parsedQuery = new StringBuffer(length);
		boolean inSingleQuote = false;
		boolean inDoubleQuote = false;
		int index = 1;

		for (int i = 0; i < length; i++) {
			char c = query.charAt(i);
			if (inSingleQuote) {
				if (c == '\'') {
					inSingleQuote = false;
				}
			} else if (inDoubleQuote) {
				if (c == '"') {
					inDoubleQuote = false;
				}
			} else {
				if (c == '\'') {
					inSingleQuote = true;
				} else if (c == '"') {
					inDoubleQuote = true;
				} else if (c == '@' && i + 1 < length &&
					Character.isJavaIdentifierStart(query.charAt(i + 1))) {
					int j = i + 2;
					while (j < length && Character.isJavaIdentifierPart(query.charAt(j))) {
						j++;
					}
					String name = query.substring(i + 1, j);
					c = '?'; // replace the parameter with a question mark
					i += name.length(); // skip past the end if the parameter

					List<Integer> indexList = (List<Integer>) paramMap.get(name);
					if (indexList == null) {
						indexList = new LinkedList<Integer>();
						paramMap.put(name, indexList);
					}
					indexList.add(new Integer(index));

					index++;
				}
			}
			parsedQuery.append(c);
		}

		return parsedQuery.toString();
	}

	static final String parseWithParams(String query) {

		for (String key : debugParams.keySet()) {
			query = query.replace("@" + key, "'" + debugParams.get(key) + "'");
		}
		debugParams.clear();

		return query;
	}

	private void startTrace() {
		if (debugMode) NamedParameterStatement.startTraceDate = new java.util.Date();
	}

	private void endTrace(String query) {
		try {
			if (debugMode) {
				long elapsedTime = new java.util.Date().getTime() - NamedParameterStatement.startTraceDate.getTime();
				if (elapsedTime > databaseQueryElapsedTimeWarning)
					agentLogger.trace(elapsedTime + " miliseconds: " + parseWithParams(this.query));
			}
		} catch (Exception ex) {
		}
	}

	/**
	 * Returns the indexes for a parameter.
	 *
	 * @param name parameter name
	 * @return parameter indexes
	 * @throws IllegalArgumentException if the parameter does not exist
	 */
	private int[] getIndexes(String name) {
		List<Integer> indexesList = indexMap.get(name);
		if (indexesList == null) throw new ParameterNotFoundInQueryException(name);
		int[] indexes = new int[indexesList.size()];
		for (int i = 0; i < indexesList.size(); i++)
			indexes[i] = indexesList.get(i);
		return indexes;
	}


	/**
	 * Sets a parameter.
	 *
	 * @param name  parameter name
	 * @param value parameter value
	 * @throws SQLException             if an error occurred
	 * @throws IllegalArgumentException if the parameter does not exist
	 * @see PreparedStatement#setObject(int, java.lang.Object)
	 */
	public void setObject(String name, Object value) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setObject(indexes[i], value);
		}
		if (debugMode) debugParams.put(name, String.valueOf(value));
	}


	/**
	 * Sets a parameter.
	 *
	 * @param name  parameter name
	 * @param value parameter value
	 * @throws SQLException             if an error occurred
	 * @throws IllegalArgumentException if the parameter does not exist
	 * @see PreparedStatement#setString(int, java.lang.String)
	 */
	public void setString(String name, String value) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setString(indexes[i], value);
		}
		if (debugMode) debugParams.put(name, value);
	}


	/**
	 * Sets a parameter.
	 *
	 * @param name  parameter name
	 * @param value parameter value
	 * @throws SQLException             if an error occurred
	 * @throws IllegalArgumentException if the parameter does not exist
	 * @see PreparedStatement#setInt(int, int)
	 */
	public void setInt(String name, int value) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setInt(indexes[i], value);
		}
		if (debugMode) debugParams.put(name, String.valueOf(value));
	}


	/**
	 * Sets a parameter.
	 *
	 * @param name  parameter name
	 * @param value parameter value
	 * @throws SQLException             if an error occurred
	 * @throws IllegalArgumentException if the parameter does not exist
	 * @see PreparedStatement#setInt(int, int)
	 */
	public void setLong(String name, long value) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setLong(indexes[i], value);
		}
		if (debugMode) debugParams.put(name, String.valueOf(value));
	}


	/**
	 * Sets a parameter.
	 *
	 * @param name  parameter name
	 * @param value parameter value
	 * @throws SQLException             if an error occurred
	 * @throws IllegalArgumentException if the parameter does not exist
	 * @see PreparedStatement#setTimestamp(int, java.sql.Timestamp)
	 */
	public void setTimestamp(String name, Timestamp value) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setTimestamp(indexes[i], value);
		}
		if (debugMode) debugParams.put(name, String.valueOf(value));
	}

	/**
	 * Sets a parameter.
	 *
	 * @param name  parameter name
	 * @param value parameter value
	 * @throws SQLException             if an error occurred
	 * @throws IOException
	 * @throws IllegalArgumentException if the parameter does not exist
	 * @see PreparedStatement#setBinaryStream(int, java.io.InputStream)
	 */
	public void setBinaryStream(String name, InputStream value) throws SQLException, IOException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			int available = 0;
			if (value != null) available = (int) value.available();
			statement.setBinaryStream(indexes[i], value, available);
		}
		if (debugMode) debugParams.put(name, String.valueOf(value));
	}

	/**
	 * Sets a parameter.
	 *
	 * @param name  parameter name
	 * @param value parameter value
	 * @throws SQLException             if an error occurred
	 * @throws IllegalArgumentException if the parameter does not exist
	 * @see PreparedStatement#setNull(int, int)
	 */
	public void setNull(String name, int sqlType) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setNull(indexes[i], sqlType);
		}
		if (debugMode) debugParams.put(name, null);
	}

	/**
	 * Sets a parameter.
	 *
	 * @param name  parameter name
	 * @param value parameter value
	 * @throws SQLException             if an error occurred
	 * @throws IllegalArgumentException if the parameter does not exist
	 * @see PreparedStatement#setDate(int, Date)
	 */
	public void setDate(String name, Date value) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setDate(indexes[i], value);
		}
		if (debugMode) debugParams.put(name, String.valueOf(value));
	}

	public void setFloat(String name, float value) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setFloat(indexes[i], value);
		}
		if (debugMode) debugParams.put(name, String.valueOf(value));
	}

	public void setDouble(String name, double value) throws SQLException {
		int[] indexes = getIndexes(name);
		for (int i = 0; i < indexes.length; i++) {
			statement.setDouble(indexes[i], value);
		}
		if (debugMode) debugParams.put(name, String.valueOf(value));
	}

	/**
	 * Returns the underlying statement.
	 *
	 * @return the statement
	 */
	public PreparedStatement getStatement() {
		return statement;
	}


	/**
	 * Executes the statement.
	 *
	 * @return true if the first result is a {@link ResultSet}
	 * @throws SQLException if an error occurred
	 * @see PreparedStatement#execute()
	 */
	public boolean execute() throws SQLException {
		boolean result;
		this.startTrace();
		result = statement.execute();
		this.endTrace(this.query);
		return result;
	}


	/**
	 * Executes the statement, which must be a query.
	 *
	 * @return the query results
	 * @throws SQLException if an error occurred
	 * @see PreparedStatement#executeQuery()
	 */
	public ResultSet executeQuery() throws SQLException {
		ResultSet result;
		this.startTrace();
		result = statement.executeQuery();
		this.endTrace(this.query);
		return result;
	}


	/**
	 * Executes the statement, which must be an SQL INSERT, UPDATE or DELETE statement;
	 * or an SQL statement that returns nothing, such as a DDL statement.
	 *
	 * @return number of rows affected
	 * @throws SQLException if an error occurred
	 * @see PreparedStatement#executeUpdate()
	 */
	public int executeUpdate() throws SQLException {
		int result;
		this.startTrace();
		result = statement.executeUpdate();
		this.endTrace(this.query.replace("%", "%%"));
		return result;
	}

	/**
	 * Executes the statement, which must be an SQL INSERT, UPDATE or DELETE statement;
	 * or an SQL statement that returns nothing, such as a DDL statement, and return a
	 * ResultSet with the generated keys. Useful for drivers that not support standard
	 * getGeneratedKeys()
	 *
	 * @return number of rows affected
	 * @throws SQLException if an error occurred
	 * @see PreparedStatement#executeUpdate()
	 */
	public ResultSet executeUpdateAndGetGeneratedKeys() throws SQLException {
		statement.executeUpdate();
		this.startTrace();
		ResultSet results = statement.getGeneratedKeys();
		this.endTrace(this.query);
		return results;
	}

	/**
	 * Closes the statement.
	 *
	 * @throws SQLException if an error occurred
	 * @see Statement#close()
	 */
	public void close() throws SQLException {
		statement.close();
	}


	/**
	 * Adds the current set of parameters as a batch entry.
	 *
	 * @throws SQLException if something went wrong
	 */
	public void addBatch() throws SQLException {
		statement.addBatch();
	}


	/**
	 * Executes all of the batched statements.
	 * <p/>
	 * See {@link Statement#executeBatch()} for details.
	 *
	 * @return update counts for each statement
	 * @throws SQLException if something went wrong
	 */
	public int[] executeBatch() throws SQLException {
		return statement.executeBatch();
	}

	public String getQuery() {
		return query;
	}

}